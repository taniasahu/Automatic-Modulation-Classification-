%% Usage of MATLAB's Communication Toolbox
%% MODULATION DATASET GENERATION 
clear; clc; rng(42);  % Reproducible results

% Parameters
modTypes = ["BPSK","QPSK","8PSK","16QAM","64QAM","GFSK","CPFSK","PAM4","B-FM","DSB-AM","SSB-AM"];
numModTypes = length(modTypes);
numFramesPerMod = 5000;
totalFrames = numFramesPerMod * numModTypes;
frameLength = 1024;
sps = 8;
fs = 200e3;              % Sampling frequency = 200 kHz
SNR_range = [-6, 20];    % SNR range
Kfactor = 4;             % Rician K-factor
maxOffset = 4;           % Max timing offset in samples
maxFreqDrift = 200;      % Max freq drift in Hz
maxPhaseOffset = 0.1;    % Max phase offset in radians

% Channel objects
ricianChan = comm.RicianChannel(...
    'SampleRate', fs, ...
    'PathDelays', [0 1.5e-5 3e-5], ...
    'AveragePathGains', [0 -2 -10], ...
    'KFactor', Kfactor, ...
    'MaximumDopplerShift', 1);
rayleighChan = comm.RayleighChannel(...
    'SampleRate', fs, ...
    'PathDelays', [0 1.5e-5 3e-5], ...
    'AveragePathGains', [0 -2 -10], ...
    'MaximumDopplerShift', 1);

% Preallocate arrays
data = zeros(totalFrames, frameLength, 2); % I/Q
labels = zeros(totalFrames, 1);            % Numeric labels (1 to 11)
split = zeros(totalFrames, 1);             % Split encoding: 0=train, 1=val, 2=test
impairments = zeros(totalFrames, 6);       % [modLabel, channelType, SNR, timingOffset, freqDrift, phaseOffset]

% Generate dataset
for frameIdx = 1:totalFrames
    m = ceil(frameIdx / numFramesPerMod);  % Modulation index
    modType = modTypes(m);
    if mod(frameIdx, numFramesPerMod) == 1
        fprintf("Generating %s signals...\n", modType);
    end

    % Generate input with buffer for filter delay
    buffer = 32;  % Buffer to account for filter delay (rrc filter length - 1)
    if ismember(modType, ["B-FM","DSB-AM","SSB-AM"])
        x = randn(frameLength + sps - 1 + buffer, 1);
    else
        M = getModOrder(modType);
        numSymbols = ceil((frameLength + sps - 1 + buffer)/sps);
        x = randi([0 M-1], numSymbols, 1);
    end

    % Modulate
    modulator = helperModClassGetModulator(modType, sps, fs);
    y = modulator(x);
    y = y(:) / (max(abs(y)) + eps);  % Amplitude normalization

    % Apply timing offset
    timingOffset = randi([-maxOffset, maxOffset]);
    y = circshift(y, timingOffset);

    % Apply fading
    channelType = randi([0 1]);  % 0: Rayleigh, 1: Rician
    if channelType == 1
        y = ricianChan(y);  % Apply Rician fading
    else
        y = rayleighChan(y);  % Apply Rayleigh fading
    end

    % Frequency drift and phase offset
    t = (0:length(y)-1)'/fs;
    fDrift = maxFreqDrift * (2*rand - 1);
    phaseOffset = maxPhaseOffset * (2*rand - 1);
    y = y .* exp(1j * (2*pi*fDrift*t + phaseOffset));

    % Add AWGN
    snrThisFrame = SNR_range(1) + (SNR_range(2)-SNR_range(1))*rand();
    y = awgn(y, snrThisFrame, 'measured');

    % Frame extraction
    startIdx = randi([1, sps]);
    endIdx = startIdx + frameLength - 1;
    if endIdx > length(y)
        y = [y; zeros(endIdx - length(y), 1)];  % Pad with zeros if necessary
    end
    frame = y(startIdx : endIdx) / sqrt(mean(abs(y).^2) + eps);

    % Normalize Power
        frame = frame / sqrt(mean(abs(frame).^2) + eps);

    % Store data
    data(frameIdx, :, 1) = real(frame);
    data(frameIdx, :, 2) = imag(frame);
    labels(frameIdx) = m;
    impairments(frameIdx, :) = [m, channelType, snrThisFrame, timingOffset, fDrift, phaseOffset];
end

%% USE ONLY IF APPLYING A UNIT CLASSIFIER INTO YOUR MODEL, used for simplification
% Pre-segment data into units (128 samples with 64 overlap)
segmentSize = 128;
overlap = 64;
segmentedData = zeros(totalFrames * floor((frameLength - overlap) / (segmentSize - overlap)), segmentSize, 2);
segmentedLabels = zeros(size(segmentedData, 1), 1);
segmentedImpairments = zeros(size(segmentedData, 1), 6);
idx = 1;
for frameIdx = 1:totalFrames
    frame = squeeze(data(frameIdx, :, :));
    numSegments = floor((length(frame) - overlap) / (segmentSize - overlap));
    for seg = 1:numSegments
        startIdx = (seg-1) * (segmentSize - overlap) + 1;
        endIdx = startIdx + segmentSize - 1;
        segmentedData(idx, :, :) = frame(startIdx:endIdx, :);
        segmentedLabels(idx) = labels(frameIdx);
        segmentedImpairments(idx, :) = impairments(frameIdx, :);
        idx = idx + 1;
    end
end
data = segmentedData;
labels = segmentedLabels;
impairments = segmentedImpairments;
totalFrames = size(data, 1);

% Stratified split based on SNR
snrValues = impairments(:, 3);
snrBins = -6:4:20;
splitProportions = [0.7 0.15 0.15];  % Train: 70%, Val: 15%, Test: 15%

for i = 1:length(snrBins)-1
    binMask = (snrValues >= snrBins(i)) & (snrValues < snrBins(i+1));
    binIndices = find(binMask);
    numBinSamples = length(binIndices);
    
    if numBinSamples > 0
        perm = randperm(numBinSamples);
        binIndices = binIndices(perm);
        
        numTrain = floor(splitProportions(1) * numBinSamples);
        numVal = floor(splitProportions(2) * numBinSamples);
        
        split(binIndices(1:numTrain)) = 0;  % Train
        split(binIndices(numTrain+1:numTrain+numVal)) = 1;  % Val
        split(binIndices(numTrain+numVal+1:end)) = 2;  % Test
    end
end

% Save dataset
save('AMC_dataset.mat', 'data', 'labels', 'split', 'impairments', 'modTypes', 'fs', '-v7');

% Verify dataset
fileInfo = dir('AMC_dataset.mat');
fprintf('Dataset saved. Size: %.2f MB\n', fileInfo.bytes/(1024^2));
test = load('AMC_dataset.mat');
fprintf('Loaded dataset with %d samples\n', size(test.data, 1));
fprintf('Impairments matrix size: %d x %d\n', size(test.impairments));
disp("Dataset Generated");

% Helper functions
function M = getModOrder(modType)
    switch modType
        case "BPSK", M = 2;
        case "QPSK", M = 4;
        case "8PSK", M = 8;
        case "16QAM", M = 16;
        case "64QAM", M = 64;
        case "PAM4", M = 4;
        case {"GFSK", "CPFSK"}, M = 2;
        otherwise, M = [];
    end
end

function modulator = helperModClassGetModulator(modType, sps, fs)
    switch modType
        case "BPSK"
            rrc = rcosdesign(0.35, 4, sps, 'normal');
            modulator = @(x) filter(rrc, 1, upfirdn(pskmod(x,2), 1, sps));
        case "QPSK"
            rrc = rcosdesign(0.35, 4, sps, 'normal');
            modulator = @(x) filter(rrc, 1, upfirdn(pskmod(x,4,pi/4), 1, sps));
        case "8PSK"
            rrc = rcosdesign(0.35, 4, sps, 'normal');
            modulator = @(x) filter(rrc, 1, upfirdn(pskmod(x,8), 1, sps));
        case "16QAM"
            rrc = rcosdesign(0.35, 4, sps, 'normal');
            modulator = @(x) filter(rrc, 1, upfirdn(qammod(x,16,'UnitAveragePower',true), 1, sps));
        case "64QAM"
            rrc = rcosdesign(0.35, 4, sps, 'normal');
            modulator = @(x) filter(rrc, 1, upfirdn(qammod(x,64,'UnitAveragePower',true), 1, sps));
        case "PAM4"
            rrc = rcosdesign(0.35, 4, sps, 'normal');
            modulator = @(x) filter(rrc, 1, upfirdn(pammod(x,4), 1, sps));
        case "GFSK"
            freqSep = fs / 10;
            gfilt = gaussdesign(0.5, 4, sps);
            modulator = @(x) filter(gfilt, 1, fskmod(x, 2, freqSep, sps, fs));
        case "CPFSK"
            freqSep = fs / 10;
            modulator = @(x) fskmod(x, 2, freqSep, sps, fs);
        case "B-FM"
            modulator = @(x) fmmod(x,15e3,fs,75e3);
        case "DSB-AM"
            modulator = @(x) ammod(x,25e3,fs);
        case "SSB-AM"
            modulator = @(x) ssbmod(x,25e3,fs);
        otherwise
            error("Unknown modulation type: " + modType);
    end
end
